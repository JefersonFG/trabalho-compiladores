#include "semantics.h"

#include <strings.h>
#include "y.tab.h"
#include "types.h"

semantic_error_node_t* global_semantic_error_list = 0;

// Adds an error to the list of semantic errors
void add_semantic_error(char* error_message);

// Creates an error message buffer with a default size
char* get_error_message_buffer();

// Declaration check functions

// Checks if the current variable has been redeclared, if not declared marks as declared
void check_and_mark_declaration(ast_node_t* node);

// Checks that a variable declaration has compatibility between variable type and initializer type
void check_variable_initialization(ast_node_t* node);

// Checks that the vector initialization values have the right type and are in the right quantity
void check_vector_initialization(ast_node_t* node);

// Converts between the ast values used for types and our own internal type constants
internal_type convert_ast_type_to_internal_type(int ast_type);

// Converts between the type tokens generated by the parser and our own internal type constants
internal_type convert_token_to_internal_type(int token);


// Verify declarations

void verify_declarations(ast_node_t* node)
{
    if (!node)
        return;

    switch (node->type) {
        case AST_VARIABLE_DECLARATION:
        case AST_VECTOR_DECLARATION:
            // Checks for redeclaration
            check_and_mark_declaration(node);

            // Checks for initializer type compatibility
            check_variable_initialization(node);
            break;
        case AST_VECTOR_INIT_DECLARATION:
            // Checks for redeclaration
            check_and_mark_declaration(node);

            // Checks for initializer values type and quantity
            check_vector_initialization(node);
            break;
        case AST_FUNCTION_DECLARATION:
            // Checks for redeclaration
            check_and_mark_declaration(node);
            break;
    }

    int i = 0;
    for (i = 0; i < NUM_SONS; i++)
        verify_declarations(node->sons[i]);
}

void check_and_mark_declaration(ast_node_t* node)
{
    if (node->symbol->declared) {
        // Already marked as declared
        char* error_message = get_error_message_buffer();
        sprintf(error_message, "variable %s already declared", node->symbol->value);
        add_semantic_error(error_message);
    } else {
        // Mark variable as declared
        node->symbol->declared = 1;
    }
}

void check_variable_initialization(ast_node_t* node)
{
    // If no initializer is given finish
    if (!node->sons[1])
        return;

    // Converts ast type into internal types
    internal_type declared_type = convert_ast_type_to_internal_type(node->sons[0]->type);

    // Here converts from type tokens into internal type
    internal_type initializer_type = convert_token_to_internal_type(node->sons[1]->symbol->token);

    // Checks that both types are compatible
    if (!are_types_compatible(declared_type, initializer_type)) {
        char* error_message = get_error_message_buffer();
        char* declared_type_string = type_to_string(declared_type);
        char* initializer_type_string = type_to_string(initializer_type);
        sprintf(error_message, "variable \'%s\' of type \'%s\' is initialized with incompatible value \'%s\' of type \'%s\'",
            node->symbol->value, declared_type_string, node->sons[1]->symbol->value, initializer_type_string);
        add_semantic_error(error_message);
    }
}

void check_vector_initialization(ast_node_t* node)
{
    // If no initializer is given finish
    if (!node->sons[1])
        return;

    printf("# Checking variable %s\n", node->symbol->value);

    // Parse initializer
    ast_node_t* initializer_node = node->sons[1];
    int parameter_quantity = atoi(initializer_node->symbol->value);

    printf("## Expects %d parameters\n", parameter_quantity);

    // Checks number of parameters
    int parameter_count = 0;
    ast_node_t* parameters = node->sons[2];

    while (parameters) {
        parameter_count++;
        parameters = parameters->sons[1];
    }

    printf("## Got %d parameters\n", parameter_count);

    if (parameter_count != parameter_quantity) {
        char* error_message = get_error_message_buffer();
        sprintf(error_message, "variable \'%s\' expected %d parameters but got %d on initialization",
            node->symbol->value, parameter_quantity, parameter_count);
        add_semantic_error(error_message);
    }
}

internal_type convert_ast_type_to_internal_type(int ast_type)
{
    switch (ast_type) {
    case AST_BOOL:
        return TYPE_BOOL;
        break;
    case AST_CHAR:
        return TYPE_CHAR;
        break;
    case AST_INT:
        return TYPE_INT;
        break;
    case AST_POINTER:
        return TYPE_POINTER;
        break;
    }
}

internal_type convert_token_to_internal_type(int token)
{
    switch (token) {
    case LIT_TRUE:
    case LIT_FALSE:
        return TYPE_BOOL;
        break;
    case LIT_CHAR:
        return TYPE_CHAR;
        break;
    case LIT_INTEGER:
        return TYPE_INT;
        break;
    }
}

void add_semantic_error(char* error_message)
{
    semantic_error_node_t* new_error = malloc(sizeof(semantic_error_node_t));
    new_error->error_message = strdup(error_message);
    new_error->next_error = 0;

    if (!global_semantic_error_list) {
        global_semantic_error_list = new_error;
    } else {
        semantic_error_node_t* last_error = global_semantic_error_list;
        while (last_error->next_error)
            last_error = last_error->next_error;
        last_error->next_error = new_error;
    }
}

char* get_error_message_buffer()
{
    const int BUFFER_SIZE = 1024;
    char *buffer = (char*) malloc(BUFFER_SIZE * sizeof(char));
    return buffer;
}

void print_semantic_error_list(semantic_error_node_t* semantic_error_list)
{
    if (!semantic_error_list)
        return;
    
    // Prints each node
    semantic_error_node_t* current_error = semantic_error_list;
    semantic_error_node_t* next_error = current_error->next_error;
    fprintf(stderr, "Semantic error: %s\n", current_error->error_message);

    while(next_error) {
        current_error = next_error;
        next_error = current_error->next_error;
        fprintf(stderr, "Semantic error: %s\n", current_error->error_message);
    }
}

void free_semantic_error_list(semantic_error_node_t* semantic_error_list)
{
    if (!semantic_error_list)
        return;
    
    // Frees each node and their error message buffers
    semantic_error_node_t* current_error = semantic_error_list;
    semantic_error_node_t* next_error = current_error->next_error;
    free(current_error->error_message);
    free(current_error);

    while(next_error) {
        current_error = next_error;
        next_error = current_error->next_error;
        free(current_error->error_message);
        free(current_error);
    }
}
