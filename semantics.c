#include "semantics.h"

#include <strings.h>
#include "y.tab.h"
#include "types.h"

semantic_error_node_t* global_semantic_error_list = 0;

// Adds an error to the list of semantic errors
void add_semantic_error(char* error_message);

// Creates an error message buffer with a default size
char* get_error_message_buffer();

// Declaration check functions

// Checks if the current variable has been redeclared, if not declared marks as declared
void check_and_mark_declaration(ast_node_t* node);

// Converts between the ast values used for types and our own internal type constants
internal_type convert_ast_type_to_internal_type(int ast_type);

// Converts between the type tokens generated by the parser and our own internal type constants
internal_type convert_token_to_internal_type(int token);


// Verify declarations

void verify_declarations(ast_node_t* node)
{
    if (!node)
        return;

    switch (node->type) {
        case AST_VARIABLE_DECLARATION:
            // Checks for redeclaration
            check_and_mark_declaration(node);

            // Converts ast type into internal types
            internal_type declared_type = convert_ast_type_to_internal_type(node->sons[0]->type);

            // Checks that type of the initializer is compatible with the variable type
            if (node->sons[1]) {
                // Here converts from type tokens into internal type
                internal_type initializer_type = convert_token_to_internal_type(node->sons[1]->symbol->token);
                if (!are_types_compatible(declared_type, initializer_type)) {
                    char* error_message = get_error_message_buffer();
                    char* declared_type_string = type_to_string(declared_type);
                    char* initializer_type_string = type_to_string(initializer_type);
                    sprintf(error_message, "variable \'%s\' of type \'%s\' is initialized with incompatible value \'%s\' of type \'%s\'",
                        node->symbol->value, declared_type_string, node->sons[1]->symbol->value, initializer_type_string);
                    add_semantic_error(error_message);
                }
            }
            break;
        case AST_VECTOR_DECLARATION:
        case AST_FUNCTION_DECLARATION:
            check_and_mark_declaration(node);
            break;
    }

    int i = 0;
    for (i = 0; i < NUM_SONS; i++)
        verify_declarations(node->sons[i]);
}

void check_and_mark_declaration(ast_node_t* node)
{
    if (node->symbol->declared) {
        // Already marked as declared
        char* error_message = get_error_message_buffer();
        sprintf(error_message, "variable %s already declared", node->symbol->value);
        add_semantic_error(error_message);
    } else {
        // Mark variable as declared
        node->symbol->declared = 1;
    }
}

internal_type convert_ast_type_to_internal_type(int ast_type)
{
    switch (ast_type) {
    case AST_BOOL:
        return TYPE_BOOL;
        break;
    case AST_CHAR:
        return TYPE_CHAR;
        break;
    case AST_INT:
        return TYPE_INT;
        break;
    case AST_POINTER:
        return TYPE_POINTER;
        break;
    }
}

internal_type convert_token_to_internal_type(int token)
{
    switch (token) {
    case LIT_TRUE:
    case LIT_FALSE:
        return TYPE_BOOL;
        break;
    case LIT_CHAR:
        return TYPE_CHAR;
        break;
    case LIT_INTEGER:
        return TYPE_INT;
        break;
    }
}

void add_semantic_error(char* error_message)
{
    semantic_error_node_t* new_error = malloc(sizeof(semantic_error_node_t));
    new_error->error_message = strdup(error_message);
    new_error->next_error = 0;

    if (!global_semantic_error_list) {
        global_semantic_error_list = new_error;
    } else {
        semantic_error_node_t* last_error = global_semantic_error_list;
        while (last_error->next_error)
            last_error = last_error->next_error;
        last_error->next_error = new_error;
    }
}

char* get_error_message_buffer()
{
    const int BUFFER_SIZE = 1024;
    char *buffer = (char*) malloc(BUFFER_SIZE * sizeof(char));
    return buffer;
}

void print_semantic_error_list(semantic_error_node_t* semantic_error_list)
{
    if (!semantic_error_list)
        return;
    
    // Prints each node
    semantic_error_node_t* current_error = semantic_error_list;
    semantic_error_node_t* next_error = current_error->next_error;
    fprintf(stderr, "Semantic error: %s\n", current_error->error_message);

    while(next_error) {
        current_error = next_error;
        next_error = current_error->next_error;
        fprintf(stderr, "Semantic error: %s\n", current_error->error_message);
    }
}

void free_semantic_error_list(semantic_error_node_t* semantic_error_list)
{
    if (!semantic_error_list)
        return;
    
    // Frees each node and their error message buffers
    semantic_error_node_t* current_error = semantic_error_list;
    semantic_error_node_t* next_error = current_error->next_error;
    free(current_error->error_message);
    free(current_error);

    while(next_error) {
        current_error = next_error;
        next_error = current_error->next_error;
        free(current_error->error_message);
        free(current_error);
    }
}
